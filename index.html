<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			* { margin: 0; }
            #btnGen { position: absolute; }
            #time {
                position: absolute;
                font-weight: 600;
                font-size: 2vh;
                margin-left: 25%;
                color: rgb(0, 255, 21);
            }
            #food {
                position: absolute;
                font-weight: 600;
                font-size: 2vh;
                margin-left: 15%;
                color: rgb(255, 0, 0);
            }
		</style>
	</head>
	<body>
        <button id="btnGen" onclick="algoritmoGenetico()">Evolucionar a generación 1</button>
        <span id="time"></span>
        <span id="food">Food: 0</span>
		<script src="three.js"></script>
		<script>

            // CubeBands, conseguira tu especie aguantar 100 dias?
            // Un juego/simulacion web que utiliza un algoritmo genetico para desarrollarse,
            // el usuario debe ir influyendo en la tribu consiguiendo los objetivos que
            // considere e ir asi menjorando la especie por medio de la genetica

            // Primero va a ser un cubo que se come minicubos e intenta sobrevivir

			// Para poder mostrar cualquier cosa con three.js, 
            // necesitamos tres cosas: escena, cámara y renderizador

            // Code 3d

            let totalComido = 0;
            let numGeneraciones = 1;
            const TIME_LIMIT = 20000; // 20 segundos

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();

            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Player
/*
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            document.addEventListener("keydown", (event) => {
                switch(event.keyCode){
                    case 37://Izquierda
                        cube.position.x -= 0.05;
                        break;
                    case 38://Arriba
                        cube.position.y += 0.05;
                        break;
                    case 39://Derecha
                        cube.position.x += 0.05;
                        break;
                    case 40://Abajo
                        cube.position.y -= 0.05;
                        break;
                }
            });

*/
            // IA

            const MAX_IA = 10;
            const MAX_MOVIMIENTOS = 1200;
            let ias = [];
            let ia_occuped = [];

            function generateIA(bool){
                const geometry_ = new THREE.BoxGeometry(0.7, 0.7, 3);
                const material_ = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
                const ia = new THREE.Mesh(geometry_, material_);

                let other, randX, randY;

                do{// Colocacion inicial

                    other = false;
                    randX = Math.round(Math.random()*-10-1);
                    randY = Math.round(Math.random()*-7);
                    if(bool % 2 == 0){
                        randY *= -1;
                    }

                    for(let i=0; i<ia_occuped.length; i++){
                        if(ia_occuped.x == randX && ia_occuped.y == randY){
                            other = true;
                        }
                    }

                }while(other);

                ia_occuped.push({ x: randX, y: randY });

                ia.name = bool;
                ia.position.x = randX;// de -10 a 10
                ia.position.y = randY;// de -7 a 7
                
                // caracteristicas

                ia.velocidad = Math.random()/10;
                ia.comido = 0;
                ia.movimientos = [];// son necesarios para que el algoritmo genetico aprenda a cambiar de opcion
                
                for(let i=0; i<MAX_MOVIMIENTOS; i++){
                    let numRand = Math.floor(Math.random()*5);
                    if(numRand == 4){
                        numRand = 1;
                    }
                    ia.movimientos.push(numRand);
                }
/*
                ia.probabilidades = {// va a ganar de momento el que descubra los ajustes aqui para barrer mejor
                    left: Math.floor(Math.random()*10+1), 
                    right: Math.floor(Math.random()*20+1), 
                    top: Math.floor(Math.random()*30+1),  
                    bottom: Math.floor(Math.random()*40+1), 
                };
*/
                ias.push(ia);

                return ia;
            }

            // Caracteristicas IA

            function caracteristicasIA(){

            }
/*
            function movimientoIA(ia){// Con probabilidad <- Para la primera simulación
                let numRand = Math.floor(Math.random()*40+1);
                if(numRand < ia.probabilidades.left){
                    ia.position.x -= ia.velocidad;
                    ia.movimientos.push(0);
                }else if(numRand < ia.probabilidades.right){
                    ia.position.x += ia.velocidad;
                    ia.movimientos.push(1);
                }else if(numRand < ia.probabilidades.top){
                    ia.position.y += ia.velocidad;
                    ia.movimientos.push(2);
                }else if(numRand < ia.probabilidades.bottom){
                    ia.position.y -= ia.velocidad;
                    ia.movimientos.push(3);
                }
            }
*/
            function movimientoIA2(ia){// Con array de direcciones <- Elegido para algoritmo genetico
                for(let i=0; i<ia.movimientos.length; i++){
                    switch(ia.movimientos[i]){
                        case 0: ia.position.x -= ia.velocidad; break;
                        case 1: ia.position.x += ia.velocidad; break;
                        case 2: ia.position.y += ia.velocidad; break;
                        case 3: ia.position.y -= ia.velocidad; break;
                    }
                }
            }

            // Food

            const FOOD = 10;
            let minicubes = [];
            let mc_occuped = [];
            
            function generateFood(bool){
                const geometry_ = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material_ = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
                const minicube = new THREE.Mesh(geometry_, material_);
                let other, randX, randY;
                do{

                other = false;
                randX = Math.round(Math.random()*10+1);
                randY = Math.round(Math.random()*7);
                if(bool % 2 == 0){
                    randY *= -1;
                }

                for(let i=0; i<mc_occuped.length; i++){
                    if(mc_occuped.x == randX && mc_occuped.y == randY){
                        other = true;
                    }
                }

                }while(other);
                mc_occuped.push({ x: randX, y: randY });

                minicube.name = bool;
                minicube.position.x = randX;// de -10 a 10
                minicube.position.y = randY;// de -7 a 7

                minicubes.push(minicube);

                return minicube;
            }

            for(let i=0; i<FOOD; i++){
                scene.add(generateFood(i));
            }

            // Simulation

            // Game
            camera.position.z = 10;
            let rebobinarMovimientos = 0;
            let fecha = new Date();

            function animate(){
                for(let i=0; i<minicubes.length; i++){
                    for(let j=0; j<ias.length; j++){
                        if(Math.round(ias[j].position.x) == minicubes[i].position.x && Math.round(ias[j].position.y) == minicubes[i].position.y){
                            scene.remove(minicubes[i]);
                            ias[j].comido++;
                            totalComido++;
                            minicubes.splice(i, 1);
                            console.log(j+" Ha comido: "+ias[j].comido)
                            document.getElementById("food").innerHTML = "Food: "+totalComido;
                            break;
                        }
                    }
                }
                document.getElementById('time').innerHTML = Math.floor((new Date()-fecha)/1000)+" segundos";
/*
                for(let i=0; i<ias.length; i++){ // Movimiento infinito
                    movimientoIA2(ias[i]);
                }
*/

                for(let i=0; i<ias.length; i++){// 60 movimientos por segundo
                    switch(ias[i].movimientos[rebobinarMovimientos]){
                        case 0: ias[i].position.x -= ias[i].velocidad; break;
                        case 1: ias[i].position.x += ias[i].velocidad; break;
                        case 2: ias[i].position.y += ias[i].velocidad; break;
                        case 3: ias[i].position.y -= ias[i].velocidad; break;
                    }
                }
                rebobinarMovimientos++;
                requestAnimationFrame(animate);
                renderer.render(scene,camera);
            }
            animate()
         
            // Algoritmo genetico
            setInterval( () => {
                console.log("Fin generación resultados: ---------------------")
                    for(let i=0; i<ias.length; i++){
                        console.log("IA: "+i);
                        console.log("ha comido: "+ias[i].comido);
                    }
                console.log("------------------------------------------------")
                algoritmoGenetico()
            },TIME_LIMIT);

            for(let i=0; i<MAX_IA; i++){
                scene.add(generateIA(i));
            }

            function algoritmoGenetico(){// se reusan las ias anteriores pero seteando de nuevo su posicion y con el nuevo genoma, es decir el array de movimientos
                fecha = new Date();
                numGeneraciones++;
                document.getElementById('btnGen').innerHTML = "Evolucionar a generación "+numGeneraciones;

                let ias_winners = faseSeleccion();// Array con los dos mejores genomas
                
                faseSustitucion(ias_winners);

                for(let i=0; i<ias.length; i++){

                    let other, randX, randY;
                    mc_occuped = [];

                    do{

                        other = false;
                        randX = Math.round(Math.random()*-10-1);
                        randY = Math.round(Math.random()*-7);
                        if(Math.round(Math.random()*3) % 2 == 0){
                            randY *= -1;
                        }

                        for(let i=0; i<ia_occuped.length; i++){
                            if(ia_occuped.x == randX && ia_occuped.y == randY){
                                other = true;
                            }
                        }

                    }while(other);

                    ias[i].position.x = randX;
                    ias[i].position.y = randY;

                    for(let i=0; i<minicubes.length; i++){
                        scene.remove(minicubes[i]);
                    }
                    minicubes = [];
                    for(let i=0; i<FOOD; i++){
                        scene.add(generateFood(i));
                    }
                }

                rebobinarMovimientos=0;
            }

            function faseSeleccion(){ // Seleccion de los 2 mejores // -Selección por torneo-
                let winners = [];
                let winnerFood = -1;
                let winnerId;
                for(let i=0; i<ias.length; i++){// First Winner
                    if(ias[i].comido > winnerFood){
                        winnerFood = ias[i].comido//Obtenemos quien gano de la generación anterior
                        winnerId = i;
                    }
                }
                console.log("Ganador 1: "+winnerId+" ha comido: "+ias[winnerId].comido);
                winners.push(ias[winnerId]);

                winnerFood = -1;
                winnerId = 0;
                for(let i=0; i<ias.length; i++){// Second Winner
                    if(ias[i].comido > winnerFood && ias[i].comido != winners[0].comido){
                        winnerFood = ias[i].comido
                        winnerId = i;
                    }
                }
                console.log("Ganador 2: "+winnerId+" ha comido: "+ias[winnerId].comido);
                winners.push(ias[winnerId]);

                return winners;
            }

            function faseCruzar(ia_movimientos){// hay que determinar un punto de corte en ambos winners[0].movimientos[puntoDeCorte] y mezclarlos
                let numCorte = Math.round(Math.random()*MAX_MOVIMIENTOS);// Num aletorio hasta 1200
                    // Se mezcla el genoma
                let ia_movimientos_cruzados = [];

                for(let j=numCorte; j<MAX_MOVIMIENTOS; j++){
                    ia_movimientos_cruzados.push(ia_movimientos[j]);
                }
                for(let j=0; j<numCorte; j++){
                    ia_movimientos_cruzados.push(ia_movimientos[j])
                }

                return ia_movimientos_cruzados;
            }

            function faseMutacion(ia_cruzado_movimientos){
                let rand = Math.round(Math.random()*MAX_MOVIMIENTOS);
                let randPos = ia_cruzado_movimientos[rand];

                if(3 == randPos){
                    ia_cruzado_movimientos[rand]--;
                }else if(0 == randPos){
                    ia_cruzado_movimientos[rand]++;
                }else{
                    if(Math.round(Math.random()*11+1) % 2 == 0){
                        ia_cruzado_movimientos[rand]++;
                    }else{
                        ia_cruzado_movimientos[rand]--;
                    }
                }

                return ia_cruzado_movimientos;
            }

            function faseSustitucion(ias_winners){

                for(let i=0; i<MAX_IA; i+=2){

                    let cruzados0 = faseCruzar(ias_winners[0].movimientos);
                    let cruzados1 = faseCruzar(ias_winners[1].movimientos);

                    let mutados0 = faseMutacion(cruzados0);
                    let mutados1 = faseMutacion(cruzados1);
                    
                    ias[i].movimientos = mutados0;
                    ias[(i+1)].movimientos = mutados1;
                }
            }

		</script>
	</body>
</html>